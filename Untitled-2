(define (boolCalc tree)
    (letrec ([matchOP
              (lambda (tree)
                (match tree
                  ['(#t)  '#t]
                  ['(~ #t) '#f]
                  ['(#f)  '#f]
                  ['(~ #f) '#t]
                  ['(#t & #f) '#f (display #f)]
                  ['(#t & #t) '#t (display #f)]
                  ['(#f & #f) '#f (display #f)]
                  ['(#f & #t) '#f (display #f)]
                  ['(#t V #f) '#t (display #f)]
                  ['(#t V #t) '#t (display #f)]
                  ['(#f V #f) '#f (display #f)]
                  ['(#f V #t) '#t (display #f)]
                  [_           tree (display "moved on")]))])
      (matchOP tree))
      (lambda (tree)
        (cond
          ;(funcMatch tree) ;in case we dont have to split
          ((member 'V tree) (splitFunct tree 'V))
          ((member '& tree) (splitFunct tree '&)))))




(define (splitFunct enteredList sym) ;define (nameofFunction listEntered splittingElement)
    ;foldr(procedure any/c list?)
    (foldr (lambda (element rest) ;keepsEverythingInOrderForConsNewList (lambda (elementWeAreOnInTheList, restOfElementsInList)
             (if (eqv? element sym) ;if (the element you are on in the list and the spliting element are equivelent)
                 (cons null rest) ;(if the rest of the elements are null?)
                 (cons (cons element (car rest))(cdr rest)))) ;() makes another list of the rest of the elements in the list)
           ;if statement and lambda end here
           (list '()) enteredList)) ;(emptyList theListWeAreWorkingWith) in thefoldr function area



********

           (define (splitFunct enteredList sym) ;define (nameofFunction listEntered splittingElement)
  ;foldr(procedure any/c list?)
  (foldr (lambda (element rest) ;keepsEverythingInOrderForConsNewList (lambda (elementWeAreOnInTheList, restOfElementsInList)
           (if (eqv? element sym) ;if (the element you are on in the list and the spliting element are equivelent)
               (cons null rest) ;(if the rest of the elements are null?)
               (cons (cons element (car rest))(cdr rest)))) ;() makes another list of the rest of the elements in the list)
         ;if statement and lambda end here
         (list '()) enteredList)) ;(emptyList theListWeAreWorkingWith) in thefoldr function area


  (define (boolCalc tree)
    (letrec ([matchOP
              (lambda (tree)
                (match tree
                  ['(#t)  '#t]
                  ['(~ #t) '#f]
                  ['(#f)  '#f]
                  ['(~ #f) '#t]
                  ['(#t & #f) '#f (display #f)]
                  ['(#t & #t) '#t (display #f)]
                  ['(#f & #f) '#f (display #f)]
                  ['(#f & #t) '#f (display #f)]
                  ['(#t V #f) '#t (display #f)]
                  ['(#t V #t) '#t (display #f)]
                  ['(#f V #f) '#f (display #f)]
                  ['(#f V #t) '#t (display #f)]
                  [_           'no-match (display "moved on")]))])
      (matchOP tree))
    (lambda (tree)
      ;(funcMatch tree) ;in case we dont have to split
      (splitFunct tree 'V)
      (or (matchf(car tree)) (match(cdr tree)))
      (splitFunct tree '&)
      (and (matchf(car tree)) (match(cdr tree)))))


(boolCalc '(#f V #f & #t))