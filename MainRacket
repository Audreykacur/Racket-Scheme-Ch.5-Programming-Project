#lang racket
(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))

(define not?
  (lambda (t)
   (cond
   ((null? t) t)
   ((eq? (car t) '~)(cond

                     ((boolean? (cadr t)) (print(not(cadr t))) (not(cadr t)) )
                      (else (not (boolCalc (cdr t) ) )))))))

(define (extra exp)
  (cond ((not (pair? exp)) exp)
        ((and (pair? exp) (null? (cdr exp))) (extra (car exp)))
        ((and (pair? exp) (pair? (car exp)) (null? (cdr (car exp))))) (extra (car exp))
        ((and (pair? exp) (null? (cdr (cdr exp))))) (extra (cadr exp))
        (else (cons (extra (car exp))
                    (extra (cdr exp))))))


(define (member? x list)
  (if (null? list) #f                       
      (if (equal? x (car list)) #t
          (if (and (list? (car list)) (member? x (car list))) #t (member? x (cdr list))))))               

(define (sublist list)
  (cond ((and (pair? list) (pair? (car list)) (null? (cdr list))) #t)
        ((and (pair? list) (null? (cdr list))) #f)
        (else #f)))

(define (print x)
  (displayln x) x)

(define boolCalc
  (letrec ((splitFunct
            (lambda (t symbol list1)
              (cond ((null? t) (list (reverse list1) '()))
                    ((eq? (car t) symbol)(list (reverse list1) (cdr t)))
                    (else (splitFunct (cdr t) symbol (cons (car t) list1)))))))
    (lambda (tree)
      (cond
        ((null?  tree) '())
        ((atom? tree) tree)
        ((member? 'V tree)(or (boolCalc(car(car(splitFunct tree 'V '())))) (boolCalc(caadr(splitFunct tree 'V '())))))
        ((member? '& tree)(and (boolCalc(car(car(splitFunct tree '& '())))) (boolCalc(caadr(splitFunct tree '& '())))))
        ((member? '~ tree) (not? tree))
        ((sublist tree) (extra tree))
        ((and (not (member? '#t tree)) (member? '#f tree)) #f)
        ((and (not (member? '#f tree)) (member? '#t tree)) #t) 
        ((member? '#t tree) #t)
        (else (display "invalid"))
              ))))

